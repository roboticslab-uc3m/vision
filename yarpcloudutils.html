<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>vision: YarpCloudUtils: point cloud utilities for YARP</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">vision
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">YarpCloudUtils: point cloud utilities for YARP</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This library contains a collection of free functions that aim to provide support for the family of <code>yarp::sig::PointCloud&lt;T&gt;</code> template specializations. For the time being, <code><a class="el" href="namespaceroboticslab_1_1YarpCloudUtils.html" title="Collection of cloud-related utilities for YARP.">roboticslab::YarpCloudUtils</a></code> allows users to:</p>
<ul>
<li>save a point cloud or triangular polygon mesh to .ply file,</li>
<li>read a point cloud or triangular polygon mesh from .ply file,</li>
<li>construct a triangular polygon mesh from a point cloud, or</li>
<li>process a point cloud to obtain another cloud.</li>
</ul>
<p>Supported data types are:</p>
<ul>
<li><code>yarp::sig::DataXY</code> (only for data import/export via .ply)</li>
<li><code>yarp::sig::DataXYZ</code></li>
<li><code>yarp::sig::DataNormal</code> (only for data import/export via .ply)</li>
<li><code>yarp::sig::DataXYZRGBA</code></li>
<li><code>yarp::sig::DataXYZI</code></li>
<li><code>yarp::sig::DataInterestPointXYZ</code></li>
<li><code>yarp::sig::DataXYZNormal</code></li>
<li><code>yarp::sig::DataXYZNormalRGBA</code></li>
</ul>
<p>XY and plain-normal types are not available for surface meshing and cloud processing.</p>
<h1><a class="anchor" id="autotoc_md13"></a>
Supported algorithms</h1>
<p>Both <code><a class="el" href="group__YarpCloudUtils.html#ga00253c9baa7383642a8a0cf5c7efc1de" title="Constructs a triangular polygon mesh from a point cloud.">roboticslab::YarpCloudUtils::meshFromCloud</a></code> and <code><a class="el" href="group__YarpCloudUtils.html#ga97415de4b9e6fbd6415697d831ec64ae" title="Processes a cloud of points.">roboticslab::YarpCloudUtils::processCloud</a></code> implement a set of <a href="https://pointclouds.org/">Point Cloud Library (PCL)</a> algorithms. A variety of PCL classes are exposed in a highly configurable pipeline:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">PCL class   </th><th class="markdownTableHeadNone">usage   </th><th class="markdownTableHeadNone">point types   </th><th class="markdownTableHeadNone">notes    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a href="https://pointclouds.org/documentation/group__common.html#gac841d05d13c925f3a3a8090d9d7ff24d"><code>pcl::transformPointCloud</code></a>   </td><td class="markdownTableBodyNone">affine transformation   </td><td class="markdownTableBodyNone">any   </td><td class="markdownTableBodyNone"><code>translation</code> (meters) and <code>rotation</code> (scaled axis-angle, radians)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a href="https://pointclouds.org/documentation/group__common.html#ga01dcf9e24dec3109a0c8a8b8f2e24bcc"><code>pcl::transformPointCloudWithNormals</code></a>   </td><td class="markdownTableBodyNone">affine transformation   </td><td class="markdownTableBodyNone">any normal type   </td><td class="markdownTableBodyNone">see above    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a href="https://pointclouds.org/documentation/classpcl_1_1_approximate_voxel_grid.html"><code>pcl::ApproximateVoxelGrid</code></a>   </td><td class="markdownTableBodyNone">cloud resampling   </td><td class="markdownTableBodyNone">any   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a href="https://pointclouds.org/documentation/classpcl_1_1_bilateral_filter.html"><code>pcl::BilateralFilter</code></a>   </td><td class="markdownTableBodyNone">cloud filtering   </td><td class="markdownTableBodyNone">XYZI(Normal)   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a href="https://pointclouds.org/documentation/classpcl_1_1_bilateral_upsampling.html"><code>pcl::BilateralUpsampling</code></a>   </td><td class="markdownTableBodyNone">cloud processing   </td><td class="markdownTableBodyNone">XYZRGBA   </td><td class="markdownTableBodyNone">organized clouds only    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a href="https://pointclouds.org/documentation/classpcl_1_1_concave_hull.html"><code>pcl::ConcaveHull</code></a>   </td><td class="markdownTableBodyNone">mesh construction   </td><td class="markdownTableBodyNone">any   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a href="https://pointclouds.org/documentation/classpcl_1_1_convex_hull.html"><code>pcl::ConvexHull</code></a>   </td><td class="markdownTableBodyNone">mesh construction   </td><td class="markdownTableBodyNone">any   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a href="https://pointclouds.org/documentation/classpcl_1_1_crop_box.html"><code>pcl::CropBox</code></a>   </td><td class="markdownTableBodyNone">cloud filtering   </td><td class="markdownTableBodyNone">any   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a href="https://pointclouds.org/documentation/classpcl_1_1_fast_bilateral_filter.html"><code>pcl::FastBilateralFilter</code></a>   </td><td class="markdownTableBodyNone">cloud filtering   </td><td class="markdownTableBodyNone">XYZ(RGBA)   </td><td class="markdownTableBodyNone">organized clouds only    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a href="https://pointclouds.org/documentation/classpcl_1_1_fast_bilateral_filter_o_m_p.html"><code>pcl::FastBilateralFilterOMP</code></a>   </td><td class="markdownTableBodyNone">cloud filtering   </td><td class="markdownTableBodyNone">XYZ(RGBA)   </td><td class="markdownTableBodyNone">organized clouds only    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a href="https://pointclouds.org/documentation/classpcl_1_1_greedy_projection_triangulation.html"><code>pcl::GreedyProjectionTriangulation</code></a>   </td><td class="markdownTableBodyNone">mesh construction   </td><td class="markdownTableBodyNone">XYZ/XYZI/XYZRGBA + Normal   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a href="https://pointclouds.org/documentation/classpcl_1_1_grid_minimum.html"><code>pcl::GridMinimum</code></a>   </td><td class="markdownTableBodyNone">cloud resampling   </td><td class="markdownTableBodyNone">any   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a href="https://pointclouds.org/documentation/classpcl_1_1_grid_projection.html"><code>pcl::GridProjection</code></a>   </td><td class="markdownTableBodyNone">surface reconstruction   </td><td class="markdownTableBodyNone">XYZ/XYZI/XYZRGBA + Normal   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a href="https://pointclouds.org/documentation/classpcl_1_1_local_maximum.html"><code>pcl::LocalMaximum</code></a>   </td><td class="markdownTableBodyNone">cloud resampling   </td><td class="markdownTableBodyNone">any   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a href="https://pointclouds.org/documentation/classpcl_1_1_marching_cubes_hoppe.html"><code>pcl::MarchingCubesHoppe</code></a>   </td><td class="markdownTableBodyNone">surface reconstruction   </td><td class="markdownTableBodyNone">XYZ/XYZI/XYZRGBA + Normal   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a href="https://pointclouds.org/documentation/classpcl_1_1_marching_cubes_r_b_f.html"><code>pcl::MarchingCubesRBF</code></a>   </td><td class="markdownTableBodyNone">surface reconstruction   </td><td class="markdownTableBodyNone">XYZ/XYZI/XYZRGBA + Normal   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a href="https://pointclouds.org/documentation/classpcl_1_1_median_filter.html"><code>pcl::MedianFilter</code></a>   </td><td class="markdownTableBodyNone">cloud filtering   </td><td class="markdownTableBodyNone">any   </td><td class="markdownTableBodyNone">organized clouds only    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a href="https://pointclouds.org/documentation/classpcl_1_1_mesh_quadric_decimation_v_t_k.html"><code>pcl::MeshQuadricDecimationVTK</code></a>   </td><td class="markdownTableBodyNone">mesh processing   </td><td class="markdownTableBodyNone">(mesh)   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a href="https://pointclouds.org/documentation/classpcl_1_1_mesh_smoothing_laplacian_v_t_k.html"><code>pcl::MeshSmoothingLaplacianVTK</code></a>   </td><td class="markdownTableBodyNone">mesh processing   </td><td class="markdownTableBodyNone">(mesh)   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a href="https://pointclouds.org/documentation/classpcl_1_1_mesh_smoothing_windowed_sinc_v_t_k.html"><code>pcl::MeshSmoothingWindowedSincVTK</code></a>   </td><td class="markdownTableBodyNone">mesh processing   </td><td class="markdownTableBodyNone">(mesh)   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a href="https://pointclouds.org/documentation/classpcl_1_1_mesh_subdivision_v_t_k.html"><code>pcl::MeshSubdivisionVTK</code></a>   </td><td class="markdownTableBodyNone">mesh processing   </td><td class="markdownTableBodyNone">(mesh)   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a href="https://pointclouds.org/documentation/classpcl_1_1_moving_least_squares.html"><code>pcl::MovingLeastSquares</code></a>   </td><td class="markdownTableBodyNone">cloud processing   </td><td class="markdownTableBodyNone">any   </td><td class="markdownTableBodyNone">requires PCL 1.9+    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a href="https://pointclouds.org/documentation/classpcl_1_1_normal_estimation.html"><code>pcl::NormalEstimation</code></a>   </td><td class="markdownTableBodyNone">normal estimation   </td><td class="markdownTableBodyNone">any   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a href="https://pointclouds.org/documentation/classpcl_1_1_normal_estimation_o_m_p.html"><code>pcl::NormalEstimationOMP</code></a>   </td><td class="markdownTableBodyNone">normal estimation   </td><td class="markdownTableBodyNone">any   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a href="https://pointclouds.org/documentation/classpcl_1_1_organized_fast_mesh.html"><code>pcl::OrganizedFastMesh</code></a>   </td><td class="markdownTableBodyNone">mesh construction   </td><td class="markdownTableBodyNone">XYZ(RGBA)   </td><td class="markdownTableBodyNone">organized clouds only    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a href="https://pointclouds.org/documentation/classpcl_1_1_pass_through.html"><code>pcl::PassThrough</code></a>   </td><td class="markdownTableBodyNone">cloud filtering   </td><td class="markdownTableBodyNone">any   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a href="https://pointclouds.org/documentation/classpcl_1_1_poisson.html"><code>pcl::Poisson</code></a>   </td><td class="markdownTableBodyNone">surface reconstruction   </td><td class="markdownTableBodyNone">XYZ/XYZI/XYZRGBA + Normal   </td><td class="markdownTableBodyNone"><code>threads</code> requires PCL 1.12+    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a href="https://pointclouds.org/documentation/classpcl_1_1_radius_outlier_removal.html"><code>pcl::RadiusOutlierRemoval</code></a>   </td><td class="markdownTableBodyNone">cloud filtering   </td><td class="markdownTableBodyNone">any   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a href="https://pointclouds.org/documentation/classpcl_1_1_random_sample.html"><code>pcl::RandomSample</code></a>   </td><td class="markdownTableBodyNone">cloud resampling   </td><td class="markdownTableBodyNone">any   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a href="https://pointclouds.org/documentation/classpcl_1_1_sampling_surface_normal.html"><code>pcl::SamplingSurfaceNormal</code></a>   </td><td class="markdownTableBodyNone">cloud resampling   </td><td class="markdownTableBodyNone">XYZ/XYZI/XYZRGBA + Normal   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a href="https://pointclouds.org/documentation/classpcl_1_1_shadow_points.html"><code>pcl::ShadowPoints</code></a>   </td><td class="markdownTableBodyNone">cloud filtering   </td><td class="markdownTableBodyNone">any normal type   </td><td class="markdownTableBodyNone">only normal types    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a href="https://pointclouds.org/documentation/classpcl_1_1surface_1_1_simplification_remove_unused_vertices.html"><code>pcl::SimplificationRemoveUnusedVertices</code></a>   </td><td class="markdownTableBodyNone">mesh simplification   </td><td class="markdownTableBodyNone">(mesh)   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a href="https://pointclouds.org/documentation/classpcl_1_1_statistical_outlier_removal.html"><code>pcl::StatisticalOutlierRemoval</code></a>   </td><td class="markdownTableBodyNone">cloud filtering   </td><td class="markdownTableBodyNone">any   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a href="https://pointclouds.org/documentation/classpcl_1_1_uniform_sampling.html"><code>pcl::UniformSampling</code></a>   </td><td class="markdownTableBodyNone">cloud resampling   </td><td class="markdownTableBodyNone">any   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a href="https://pointclouds.org/documentation/classpcl_1_1_voxel_grid.html"><code>pcl::VoxelGrid</code></a>   </td><td class="markdownTableBodyNone">cloud resampling   </td><td class="markdownTableBodyNone">any   </td><td class="markdownTableBodyNone"></td></tr>
</table>
<p>Mesh construction methods preserve the original point cloud as the surface vertices and simply construct the mesh on top, while surface reconstruction changes the topology of the input cloud.</p>
<h1><a class="anchor" id="autotoc_md14"></a>
Configuration</h1>
<p>YARP mechanisms are taken advantage of to set up the pipeline, especially in terms of the dictionary of key-values provided by <code>yarp::os::Property</code>. Depending on the selected function overload, each step of the pipeline corresponds either to an element of a vector of such dictionaries, or a group/dictionary within a named section collection context.</p>
<p>As a rule of thumb, there will always be a key named <code>algorithm</code> which corresponds to one of the supported PCL classes, i.e. the paired value must be equal to the class name of the selected algorithm.</p>
<p>Remaining keys of the configured step, if any, correspond to configuration setters pertaining to the algorithm, always following the camelCase naming convention. For instance, in order to access the <code>pcl::Poisson::setMinDepth</code> setter, one would create a dictionary key named <code>minDepth</code> and assign it an integer value. In a similar manner, dictionary values are mapped to enumerations, e.g. <code>pcl::OrganizedFastMesh::TriangulationType:QUAD_MESH</code> can be requested by assigning <code>quadMesh</code> to key <code>triangulationType</code>.</p>
<p>In absence of key-value entries (beyond the mandatory <code>algorithm</code> one), the pipeline assumes default values as defined by each class constructor.</p>
<p><b>Note:</b> mind input/output types for each step. If the output of step N is not compatible with the expected input of step N+1, an error will be reported.</p>
<h2><a class="anchor" id="autotoc_md15"></a>
Vector of dictionaries</h2>
<p>The most straightforward way to configure a pipeline is using the <code>VectorOf&lt;Property&gt;</code> overload. Each element of the vector is one step of the pipeline, order is preserved:</p>
<div class="fragment"><div class="line">yarp::sig::VectorOf&lt;yarp::os::Property&gt; options {</div>
<div class="line">    {</div>
<div class="line">        {<span class="stringliteral">&quot;algorithm&quot;</span>, yarp::os::Value(<span class="stringliteral">&quot;VoxelGrid&quot;</span>)},</div>
<div class="line">        {<span class="stringliteral">&quot;leafSize&quot;</span>, yarp::os::Value(0.02f)}</div>
<div class="line">    },</div>
<div class="line">    {</div>
<div class="line">        {<span class="stringliteral">&quot;algorithm&quot;</span>, yarp::os::Value(<span class="stringliteral">&quot;NormalEstimationOMP&quot;</span>)},</div>
<div class="line">        {<span class="stringliteral">&quot;kSearch&quot;</span>, yarp::os::Value(40)}</div>
<div class="line">    },</div>
<div class="line">    {</div>
<div class="line">        {<span class="stringliteral">&quot;algorithm&quot;</span>, yarp::os::Value(<span class="stringliteral">&quot;Poisson&quot;</span>)}</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">bool</span> ret = <a class="code hl_function" href="group__YarpCloudUtils.html#ga00253c9baa7383642a8a0cf5c7efc1de">roboticslab::YarpCloudUtils::meshFromCloud</a>(cloud, vertices, indices, options);</div>
<div class="ttc" id="agroup__YarpCloudUtils_html_ga00253c9baa7383642a8a0cf5c7efc1de"><div class="ttname"><a href="group__YarpCloudUtils.html#ga00253c9baa7383642a8a0cf5c7efc1de">roboticslab::YarpCloudUtils::meshFromCloud</a></div><div class="ttdeci">bool meshFromCloud(const yarp::sig::PointCloud&lt; T1 &gt; &amp;cloud, yarp::sig::PointCloud&lt; T2 &gt; &amp;meshPoints, yarp::sig::VectorOf&lt; int &gt; &amp;meshIndices, const yarp::sig::VectorOf&lt; yarp::os::Property &gt; &amp;options)</div><div class="ttdoc">Constructs a triangular polygon mesh from a point cloud.</div><div class="ttdef"><b>Definition</b> YarpCloudUtils-pcl.cpp:286</div></div>
</div><!-- fragment --><p>The above pipeline will first downsample the input cloud using the <code>pcl::VoxelGrid</code> algorithm with a leaf size of 2 cm. Since <code>pcl::Poisson</code> requires an input normal type, we estimate normals with an intermediate <code>NormalEstimation</code> step, and then perform surface reconstruction.</p>
<h2><a class="anchor" id="autotoc_md16"></a>
Configuration context</h2>
<p>Handy overloads are provided for both <code>meshFromCloud</code> and <code>processCloud</code> to parse the pipeline from a configuration file or similar context (e.g. command line) using the YARP native configuration format (see <a href="https://www.yarp.it/git-master/yarp_config_files.html">YARP config files</a>).</p>
<p>The same behavior shown in the previous section can be achieved with an .ini file such as:</p>
<div class="fragment"><div class="line">[myPipeline downsample]</div>
<div class="line">algorithm &quot;VoxelGrid&quot;</div>
<div class="line">leafSize 0.02f</div>
<div class="line"> </div>
<div class="line">[myPipeline estimate]</div>
<div class="line">algorithm &quot;NormalEstimationOMP&quot;</div>
<div class="line">kSearch 40</div>
<div class="line"> </div>
<div class="line">[myPipeline reconstruct]</div>
<div class="line">algorithm &quot;Poisson&quot;</div>
</div><!-- fragment --><p>Then, in C++ code:</p>
<div class="fragment"><div class="line">yarp::os::Property config;</div>
<div class="line">config.fromConfigFile(<span class="stringliteral">&quot;path/to/file.ini&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">bool</span> ret = <a class="code hl_function" href="group__YarpCloudUtils.html#ga00253c9baa7383642a8a0cf5c7efc1de">roboticslab::YarpCloudUtils::meshFromCloud</a>(cloud, vertices, indices, config, <span class="stringliteral">&quot;myPipeline&quot;</span>);</div>
</div><!-- fragment --><p>The <code>myPipeline</code> element is the name of the section collection which is common to all steps in this configuration (see <a href="https://www.yarp.it/git-master/yarp_config_files.html#yarp_config_file_lists">YARP docs</a>). We can express this intent also directly in C++ code:</p>
<div class="fragment"><div class="line">yarp::os::Property config(<span class="stringliteral">&quot;(myPipeline downsample estimate reconstruct)&quot;</span>);</div>
<div class="line">config.addGroup(<span class="stringliteral">&quot;downsample&quot;</span>) = {</div>
<div class="line">    {<span class="stringliteral">&quot;algorithm&quot;</span>, yarp::os::Value(<span class="stringliteral">&quot;VoxelGrid&quot;</span>)},</div>
<div class="line">    {<span class="stringliteral">&quot;leafSize&quot;</span>, yarp::os::Value(0.02f)}</div>
<div class="line">};</div>
<div class="line">config.addGroup(<span class="stringliteral">&quot;estimate&quot;</span>) = {</div>
<div class="line">    {<span class="stringliteral">&quot;algorithm&quot;</span>, yarp::os::Value(<span class="stringliteral">&quot;NormalEstimationOMP&quot;</span>)},</div>
<div class="line">    {<span class="stringliteral">&quot;kSearch&quot;</span>, yarp::os::Value(40)}</div>
<div class="line">};</div>
<div class="line">config.addGroup(<span class="stringliteral">&quot;reconstruct&quot;</span>) = {</div>
<div class="line">    {<span class="stringliteral">&quot;algorithm&quot;</span>, yarp::os::Value(<span class="stringliteral">&quot;Poisson&quot;</span>)}</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">bool</span> ret = <a class="code hl_function" href="group__YarpCloudUtils.html#ga00253c9baa7383642a8a0cf5c7efc1de">roboticslab::YarpCloudUtils::meshFromCloud</a>(cloud, vertices, indices, config, <span class="stringliteral">&quot;myPipeline&quot;</span>);</div>
</div><!-- fragment --><p>Or, via command line:</p>
<div class="fragment"><div class="line">application --myPipeline downsample estimate reconstruct \</div>
<div class="line">            --downsample::algorithm VoxelGrid --downsample::leafSize 0.02f \</div>
<div class="line">            --estimate::algorithm NormalEstimationOMP --estimate::kSearch 40 \</div>
<div class="line">            --reconstruct::algorithm Poisson</div>
</div><!-- fragment --><div class="fragment"><div class="line">yarp::os::Property config;</div>
<div class="line">config.fromCommand(argc, argv);</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">bool</span> ret = <a class="code hl_function" href="group__YarpCloudUtils.html#ga00253c9baa7383642a8a0cf5c7efc1de">roboticslab::YarpCloudUtils::meshFromCloud</a>(cloud, vertices, indices, config, <span class="stringliteral">&quot;myPipeline&quot;</span>);</div>
</div><!-- fragment --><p>In case you want to maintain a collection of pipeline configurations, each one placed within its own .ini file, then select the most appropriate for the task at hand, it is advised to use the <code>include</code> feature combined with simultaneous section collection (<a href="https://www.yarp.it/git-master/yarp_config_files.html#yarp_config_file_includes">docs</a>). Refer to YARP documentation for further examples and a similar functionality related to directory inclusion.</p>
<h1><a class="anchor" id="autotoc_md17"></a>
See also</h1>
<p>Bartek Łukawski, Alberto Rodríguez-Sanz, Elisabeth Menendez, Juan G. Victores, and Carlos Balaguer. A user-friendly point cloud processing pipeline for interfacing PCL with YARP. In <em>XLV Jornadas de Automática</em>. Universidade da Coruña, 2024.</p>
<p>```bibtex @inproceedings{lukawski2024jjaa, author = {{\L}ukawski, Bartek and Rodríguez-Sanz, Alberto and Menendez, Elisabeth and Victores, Juan G. and Balaguer, Carlos}, title = {A user-friendly point cloud processing pipeline for interfacing {PCL} with {YARP}}, booktitle = {XLV Jornadas de Automática}, year = {2024}, publisher = {Universidade da Coruña}, doi = {10.17979/ja-cea.2024.45.10925} } </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
